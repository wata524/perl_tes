
#use strict; #厳格チェック
#use warnings; 
# 以下文字コード指定
use utf8;
binmode STDIN, ':encoding(cp932)';
binmode STDOUT, ':encoding(cp932)';
binmode STDERR, ':encoding(cp932)';

print "aaa\n";

print "単純変数\n";
$xx = 5;          # スカラー変数$xxに数値5を代入します。
$xx = "abc";      # スカラー変数$xxに文字列abcを代入します。
print "$xx\n";    # スカラー変数$xxの値を参照して表示します。

print "配列\n";
# 配列定義
# @xx = ( "aa", "bb" );       # 配列xxにaa,bbを代入します。


$xx[0] = 5;        # 0番目の要素に数値5を代入します。
$xx[1] = "abc";    # 1番目の要素に文字列abcを代入します。
print "$xx[1]\n";  # 1番目の要素の内容abcを表示します。

print "＄＃変数名 は、＠変数名 の配列の最後の添え字（個数から１をひいたもの）を表わします。\n";
@xx = ( "aa", "bb", "cc", "dd" );
print "$#xx\n";    # 3と表示されます。

# いろいろできる
#$x = shift(@xx);      # 最初の要素を取り除き、これを返す
#$x = pop(@xx);        # 最後の要素を取り除き、これを返す
#push(@xx1, $xx);      # 最後に要素を追加する
#push(@xx1, @xx2);     # @xx1 の後ろに @xx2 の要素を追加する
#splice(@xx, 3, 2);    # $xx[3..4](2個)を取り除き、これを返す
#reverse(@xx);         # @xxの要素を逆順にしたものを返す
#sort(@xx);            # @xxの要素をソートした結果を返す
#@x = split(/,/, $s);  # 文字列$sを","で分割してその配列を返す

# 逆順に並び替え
@xx = reverse(@xx);

print "すべての配列要素について処理を行う \n";
foreach $i (@xx) {
    print "$i\n";
}

print "配列同士の一括代入が可能です。\n";
( $year, $mon, $day ) = ( 1997, 2, 3 );
print "$year, $mon, $day\n"; # aa


print "環境変数⇒ $ENV{'PATH'}\n";        # 環境変数PATHの値を表示する
$ENV{'TZ'} = "JST-9";      # 環境変数TZに値を設定する

# コマンド引数($ARGV)
#@ARGV          # 引数の配列
#$#ARGV         # 配列の個数－1
#$ARGV[0]       # 最初の引数
#$ARGV[$#ARGV]  # 最後の引数

# シグナル($SIG{'XXX'})
# シグナルはプログラムに送信される非同期のメッセージです。
# 例えば、強制終了を明示された時はSIGTERMシグナルが、プロセス間の通信が切断された時はSIGPIPEメッセージが、
# 設定しておいた時刻になったらSIGALRMシグナルが、プログラムに対して送信されます。
# $SIG{'TERM'} = "sigexit";
# と宣言することにより、そのプログラムに SIGTERMシグナルが送信された時に、
# &sigexit()関数が実行されるようになります。

#ビット演算子
#$xx | $yy           # $xxと$yyのOR
#$xx & $yy           # $xxと$yyのAND
#~$xx                # $xxのビットをすべて反転させたもの
#$xx << 2            # $xxを2ビット左シフト
#$xx >> 2            # $xxを2ビット右シフト(上位ビットには符号ビットを埋める)

#文字列比較演算子
#if ($xx eq $yy)            # $xxと$yyが等しければ
#if ($xx ne $yy)            # $xxと$yyが異なっていれば
#if ($xx lt $yy)            # $xxが$yyより小さければ
#if ($xx gt $yy)            # $xxが$yyより大きければ
#if ($xx le $yy)            # $xxが$yyより等しいか小さければ
#if ($xx ge $yy)            # $xxが$yyより等しいか大きければ
#if ($xx =~ /ABC/)          # $xxがABCという文字を含んでいれば
#if ($xx !~ /ABC/)          # $xxがABCという文字を含んでいなければ
#if ($xx cmp $yy)           # 比較し、-1, 0, 1 のいずれかで返す

#####################
# ◆ 条件演算子
#####################

# A ? B : C は、Aが真であればBを、偽であればCを値とします。
# 下記の例では$yyの値が5未満であれば"small"を、さもなくば"big"を$xxに代入します。
#$xx = ($yy < 5) ? "small" :  "big";

#####################
# 正規表現
#####################

#if ($xx =~ /[0-9]+/)        # 正規表現にマッチすれば
#if ($xx !~ /[0-9]+/)        # 正規表現にマッチしなければ
#置換文字列の中に括弧を書くと、その括弧に対応した文字列を
# $1, $2, ... で参照することができます。次の例は、12:34:56の秒数を求めます。
#
$xx = "12:34:56";
if ($xx =~ /([0-9][0-9]):([0-9][0-9]):([0-9][0-9])/) {
    print $1 * 3600 + $2 * 60 + $3 . "\n"; # 計算結果と文字をくっつける場合は .
}

#####################
# 文字列処理と正規表現
#####################

#文字列連結 文字列を連結します。
#
#$xx = $yy . $zz;    # 文字列 $yy と 文字列 $zz を連結します
#$xx .= $yy;         # $xx = $xx . $yy と同様です。

#文字列置換
#最後の g を省略した場合は、最初に現れたabcを1度だけ置換します。
#$xx =~ s/abc/ABC/g;
# タグ付き正規表現も可能
#$xx = "12:34:56";
#$xx =~ s/([0-9][0-9]):([0-9][0-9]):([0-9][0-9])/$1時$2分$3秒/g;

#eオプションは、ABCの部分を文字列ではなく、perlの実行文と解釈して
#その結果に置換します。次の例は、12:34:56を秒数に置換します。
#
#$xx = "12:34:56";
#$xx =~ s/([0-9][0-9]):([0-9][0-9]):([0-9][0-9])/$1*3600+$2*60+$3/e;
#
#任意の区切り文字を使用可能
#$xx =~ s/http:\/\/www.yyy.zzz\//http:\/\/aaa.bbb.ccc\//;
#$xx =~ s|http://www.yyy.zzz/|http://aaa.bbb.ccc/|;
#
#$を文字列として解釈させる場合は'を使う
#$yy = "YY";
#$xx = "999"; $xx =~ s/[0-9]/$yy/g;    # YYYYYY となる
#$xx = "999"; $xx =~ s'[0-9]'$yy'g;    # $yy$yy$yy となる
#
#次の例は、URLエンコードされた %20 のような文字列をデコードします。CGIなどではよく使用される構文です。
#$xx =~ s/%([0-9a-fA-F][0-9a-fA-F])/pack("C", hex($1))/eg;

#◆ 繰り返し演算子
#print '-' x 80;     # '-'を80個表示します。
#$xx x= 80;          # $xx を80回繰り返したものを$xxに代入します。
#@ones = (1) x 80;   # 80個の(1, 1, 1, 1, ......, 1)と同様です。

#◆ 範囲演算子
#@xx = (0 .. 5);     # @xx = (0, 1, 2, 3, 4, 5);と同様。
#for (0 .. 5)        # for ($_ = 0; $_ <= 5; $_++) と同様


###############################
# 条件文
# if, do, while, for, foreach, 
###############################
#◆ unless文
#unless(...)はif(...)と逆の意味を持ちます。
#
$xx = 5;
unless ($xx > 5) {
    print "5より大きくない\n";
}

#last文
#C言語のbreakと同じ動きをします
#next文
#C言語のcontinueと同じ動きをします

###############
# ファイル処理
###############

#◆ ファイル検査
#次のようにして、ファイルが書き込み可能かどうかなどを検査することができます。
#
# ファイル名で指定する
#if (-w "file.txt") { print "書き込み可能Write\n"; }

# ファイルハンドルで指定する
#open(IN, "file.txt");
#if (-r IN) { print "読み込み可能\n"; }
#close(IN);

# アンダーライン( _ )は最後に検査されたファイルを示す
#if (-r "file.txt") { print "読み込み可能\n"; }
#if (-w _) { print "書き込み可能\n"; }

# stat()を用いた例
#stat("file.txt");
#if (-r _) { print "読み込み可能\n"; }


# ファイル読み込み
#ファイルから各行を読み込むには次のようにします。ここで、INのような変数をファイルハンドルと呼びます。
#ファイルハンドルはINでもHEHEHEでもGUGOGOでも、自分の好きな名前で構いません。
#ファイルを読み書きする際は、ファイル名ではなく、このファイルハンドルを指定することになります。

$file = "datafile.txt";
print "ファイル読み込み -> $file \n";
open(IN, $file);
while ($xx = <IN>) { print $xx; }
close(IN);

# 暗黙の変数 $_
open(IN, "datafile.txt");
while (<IN>) { print; }
close(IN);
# これは、次の記述と同じ意味を持ちます。
open(IN, "datafile.txt");
while ($_ = <IN>) { print $_; }
close(IN);

# 次のようにファイルの各行を配列に一括して読み込むこともできます。
#
#open(IN, "datafile.txt");
#@xx = <IN>;
#foreach $yy (@xx) {
#    print $yy;
#}
#close(IN);

#ファイルに何かを書き込むには次のようにします。
#
#open(OUT, "> datafile.txt");
#print(OUT "こんにちわ\n");
#close(OUT);
#ファイルに追加書き込みするには次のようにします。
#
#open(OUT, ">> datafile.txt");
#print(OUT "こんにちわ\n");
#close(OUT);

# 標準入出力
#ハンドルは open() を用いて作成する他に、次の3つのハンドルがあらかじめオープンされています。
#STDIN     標準入力
#STDOUT    標準出力
#STDERR    標準エラー出力
#
#標準入力から各行を読み込むには次のようにします。
#while (<STDIN>) {
#    print;
#}
#
#< >の中のSTDINは省略することができます。以下のようにした場合、
#コマンドの引数で何も指定しなかった場合は標準入力から、コマンドの引数で
#ファイルのリストを指定した場合は、そのファイルを順次読み取ることができます。
#while (<>) {
#    print;
#}

#入力ファイルの改行コードに関わらず、自分の環境に適した改行コードに変換するには以下のようにします。
#while (<IN>) {
#    s/[\r\n]*$//;
#    print "$_\n";
#}

###############
# 外部コマンド実行
###############

#出力結果を外部コマンドに渡すこともできます。
#次の例ではprint文の出力をnkfコマンドでJISコードに変換して出力しています。
#
#open(OUT, "| /usr/local/bin/nkf -j");
#print(OUT "こんにちわ\n");
#close(OUT);
#また、外部コマンドの出力結果を読み取ることもできます。
#次の例では、datafile.txt の中身を nkf コマンドでEUCに変換したデータを読み込みます。
#
#open(IN, "/usr/local/bin/nkf -e datafile.txt |");
#while (<IN>) {
#    print $_;
#}
#close(IN);
#単に外部コマンドを実行するだけであれば、次のようにします。
#
#system("/usr/local/bin/nkf -e datafile.txt");

##################################
# サブルーチンと外部モジュールの呼び出し
##################################

sub add {
    return($_[0] + $_[1]); # 引数は特殊配列変数 @_ に格納されるので、$_[0], $_[1], $_[2],...として参照する
}

print &add(3, 5);

# デフォルトがglobal変数だが、ローカル変数も使える
#sub add {
#    local(@a) = @_;
#    local($i);
#    local($ans) = 0;
#    for ($i = 0; $i <= $#a; $i++) {
#        $ans += $a[$i];
#    }
#    return($ans);
#}

# 変数に*を付けると参照渡しとなる
# また複数の配列を渡す時も、参照渡しが必要
sub listprint {
    local(*list1, *list2) = @_;
    print "[ "; print @list1; print " ]\n";
    print "[ "; print @list2; print " ]\n";
}
@xx = (1, 2, 3);
@yy = (4, 5, 6);
&listprint(*xx, *yy); 

# 外部パッケージ呼び出しと関数実行
$pkg = "mycalc.pl";
require $pkg; # パールスゲー ＼(゜ロ＼)(／ロ゜)／
print &mycalc'add(3, 5) . "\n";

####################
# インライン入力
####################

#<<によるデータ表記
#次の例では、「Hello World!!」という文字列を3行表示します。
#END_OF_DATAの部分はどんな文字列でも使用できますが、
#　(1)<<の後ろにはスペースを空けてはならない、
#　(2)最初のEND_OF_DATAの後ろにはセミコロン(;)が必要、
#　(3)最後のEND_OF_DATAの後ろには改行が必要、
#など注意点も多いので気を付けてください。

print <<END_OF_DATA;
Hello World!!
Hello World!!
Hello World!!
END_OF_DATA

#次の例では、変数 $msg に 3行のメッセージを代入しています。
$msg = <<END_OF_DATA;
This is Japan.
That is America.
That is England.
END_OF_DATA
print $msg;

#次の例でも同様に、「Hello World!!」を3行表示します。この場合、空行がデータの終わりを示します。）
print << x 3;
Hello World!!


##########################################
# リファレンス機能（Cのポインタと構造体） ※ここから
##########################################

